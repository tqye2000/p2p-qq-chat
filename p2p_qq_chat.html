<!--
A simple peer-to-peer encrypted chat application (P2P QQ Chat) using WebRTC (via PeerJS) and Web Crypto API.
- Peer-to-peer connection using WebRTC (no server relay after connection).
- End-to-end encryption using AES-GCM derived from a shared password.

Features
- Serverless Data: Chat messages go directly from User A to User B (P2P). No database stores your chats.
- Client-Side Encryption: You set a "Secret Password." 
  Messages are encrypted before they leave your browser and decrypted only when they reach the other person. 
  Even if someone intercepted the P2P traffic, they would only see garbage data.
- No Installation: Runs entirely in the browser.

How to use it
- Open this file in two different browser tabs (or send the file to a friend).
    Tab 1: Copy "My ID".
    Tab 2: Paste that into "Friend's ID" and click Connect.
- Choose ID persistence (optional):
   * By default, the "Remember my ID" checkbox is checked, meaning your ID will be saved and reused across sessions
   * Uncheck it if you prefer a new random ID each time you reload the page
- Both Tabs: Enter the same "Secret Encryption Key" (password).
- Chat away.

Note: This is a demo for educational purposes. For production use, consider additional security measures.

History
Date       | Author      | Description
18/11/2025 | Gemini 3    | Created upon user request for a simple P2P encrypted chat demo.
19/11/2025 | TQ Ye       | Added checkbox to toggle saving/loading peer ID from localStorage.
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>安全P2P加密聊天</title>
    <!-- PeerJS for WebRTC (Networking) -->
    <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
    <!-- Tailwind CSS for Styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #f0f2f5; }
        .message-bubble { max-width: 75%; word-wrap: break-word; }
    </style>
</head>
<body class="h-screen flex flex-col items-center justify-center p-4">

    <div class="w-full max-w-md bg-white rounded-lg shadow-xl overflow-hidden flex flex-col h-[80vh]">
        <!-- Header -->
        <div class="bg-blue-600 p-4 text-white">
            <h1 class="text-lg font-bold">端到端加密悄悄话</h1>
            <div class="text-xs mt-1 opacity-80">状态: <span id="status-text">初始化中...</span></div>
        </div>

        <!-- Connection Setup Area -->
        <div id="setup-panel" class="p-4 bg-gray-50 border-b border-gray-200 text-sm space-y-3">
            <div>
                <label class="block text-gray-600 mb-1">我的 ID (分享给朋友):</label>
                <div class="flex gap-2">
                    <input type="text" id="my-id" readonly class="flex-1 p-2 border rounded bg-gray-100 text-gray-500 font-mono">
                    <button onclick="copyId()" class="bg-gray-200 hover:bg-gray-300 px-3 rounded text-gray-700">复制</button>
                </div>
                <div class="mt-2 flex items-center gap-2">
                    <input type="checkbox" id="save-id-checkbox" class="w-4 h-4 text-blue-600" onchange="handleSaveIdToggle()" checked>
                    <label for="save-id-checkbox" class="text-gray-600 text-xs cursor-pointer">记住我的 ID (重新加载页面以应用)</label>
                </div>
            </div>
            
            <div class="flex gap-2">
                <div class="flex-1">
                    <label class="block text-gray-600 mb-1">朋友的 ID:</label>
                    <input type="text" id="friend-id" class="w-full p-2 border rounded font-mono" placeholder="粘贴朋友的 ID 在这里">
                </div>
                <div class="flex items-end">
                    <button id="connect-btn" class="bg-blue-600 hover:bg-blue-700 text-white p-2 rounded w-full" onclick="connectToPeer()">连接</button>
                </div>
            </div>

            <div>
                <label class="block text-gray-600 mb-1 font-bold">秘密加密密码:</label>
                <input type="password" id="secret-key" class="w-full p-2 border border-yellow-400 rounded bg-yellow-50" placeholder="双方必须输入相同的密码">
                <p class="text-xs text-gray-500 mt-1">消息使用从此密码派生的 AES-GCM 进行加密。</p>
            </div>
        </div>

        <!-- Chat Area -->
        <div id="chat-box" class="flex-1 overflow-y-auto p-4 space-y-3 bg-gray-100">
            <!-- Messages appear here -->
            <div class="text-center text-gray-400 text-xs mt-4">等待连接中...</div>
        </div>

        <!-- Input Area -->
        <div class="p-3 bg-white border-t border-gray-200 flex gap-2">
            <input type="text" id="message-input" class="flex-1 p-2 border rounded focus:outline-none focus:border-blue-500" placeholder="输入秘密消息..." disabled>
            <button id="send-btn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded disabled:bg-gray-300 disabled:cursor-not-allowed" onclick="sendMessage()" disabled>发送</button>
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        let peer = null;
        let conn = null;
        let myCryptoKey = null; // The derived AES key
        
        const statusText = document.getElementById('status-text');
        const chatBox = document.getElementById('chat-box');
        const msgInput = document.getElementById('message-input');
        const sendBtn = document.getElementById('send-btn');
        const connectBtn = document.getElementById('connect-btn');

        // --- Initialization (PeerJS) ---
        // We use the default PeerJS cloud server for signaling (finding each other).
        // Data goes P2P, not through their server after connection.
        
        // Check if user wants to save/load ID (default to true if not set)
        const saveIdPreference = localStorage.getItem('save_id_preference');
        const shouldSaveId = saveIdPreference === null ? true : saveIdPreference === 'true';
        const savedId = localStorage.getItem('my_chat_app_id');
        
        // Create a new Peer with saved ID if preference is enabled, otherwise random
        if (shouldSaveId && savedId) {
            peer = new Peer(savedId);
        } else {
            peer = new Peer(); // This generates a random ID every time you load or refresh the page.
        }

        peer.on('open', (id) => {
            document.getElementById('my-id').value = id;
            statusText.textContent = "连接准备就绪。";
            
            // Save the ID if preference is enabled
            if (shouldSaveId) {
                localStorage.setItem('my_chat_app_id', id);
            }
        });

        peer.on('connection', (connection) => {
            setupConnection(connection);
        });

        peer.on('error', (err) => {
            console.error(err);
            
            // Handle "ID Taken" error (can happen if saved ID is stuck on server)
            if (err.type === 'unavailable-id') {
                alert("您保存的 ID 当前不可用。正在生成一个新的...");
                localStorage.removeItem('my_chat_app_id');
                window.location.reload();
            } else {
                alert("连接错误: " + err.type);
            }
        });
        
        // Set checkbox state based on saved preference
        document.getElementById('save-id-checkbox').checked = shouldSaveId;

        // // Another initialization approach:
        // // 1. Check if we already have an ID saved in this browser
        // const savedId = localStorage.getItem('my_chat_app_id');

        // // 2. If we have one, try to reuse it. If not, let PeerJS generate a new one.
        // if (savedId) {
        //     peer = new Peer(savedId);
        // } else {
        //     peer = new Peer();
        // }

        // peer.on('open', (id) => {
        //     // 3. Save the ID for next time
        //     localStorage.setItem('my_chat_app_id', id);
            
        //     document.getElementById('my-id').value = id;
        //     statusText.textContent = "Ready to connect.";
        // });
        
        // // 4. Handle "ID Taken" error (rare, but happens if the ID is stuck on the server)
        // peer.on('error', (err) => {
        //     if (err.type === 'unavailable-id') {
        //         alert("Your saved ID is currently stuck. Clearing it. Please refresh.");
        //         localStorage.removeItem('my_chat_app_id');
        //         window.location.reload();
        //     } else {
        //         console.error(err);
        //         alert("Error: " + err.type);
        //     }
        // });

        // --- Connection Logic ---
        function connectToPeer() {
            const friendId = document.getElementById('friend-id').value.trim();
            if (!friendId) return alert("请输入朋友的 ID");
            const connection = peer.connect(friendId);
            setupConnection(connection);
        }

        function setupConnection(connection) {
            conn = connection;
            
            conn.on('open', () => {
                statusText.textContent = "连接成功！安全通道已打开。";
                statusText.parentElement.classList.remove('bg-blue-600');
                statusText.parentElement.classList.add('bg-green-600');
                
                // Enable UI
                msgInput.disabled = false;
                sendBtn.disabled = false;
                connectBtn.disabled = true;
                chatBox.innerHTML = '<div class="text-center text-xs text-green-600 mb-2">--- 连接成功 ---</div>';
            });

            conn.on('data', async (data) => {
                // Data received: { iv: Array, cipher: Array }
                if(data.iv && data.cipher) {
                    try {
                        const plaintext = await decryptMessage(data);
                        addMessageToUI(plaintext, 'received');
                    } catch (e) {
                        console.error(e);
                        addMessageToUI("⚠️ 解密失败: 密码错误？", 'error');
                    }
                }
            });

            conn.on('close', () => {
                statusText.textContent = "断开连接。";
                msgInput.disabled = true;
                sendBtn.disabled = true;
                alert("连接丢失。请刷新页面重新连接。");
            });
        }

        // --- Encryption / Decryption Logic (Web Crypto API) ---
        
        // 1. Derive a Key from the user's password
        async function getCryptoKey() {
            const password = document.getElementById('secret-key').value;
            if (!password) throw new Error("密码是必需的以加密/解密消息。");

            const enc = new TextEncoder();
            const keyMaterial = await window.crypto.subtle.importKey(
                "raw", 
                enc.encode(password), 
                { name: "PBKDF2" }, 
                false, 
                ["deriveKey"]
            );

            // In a real app, the salt should be random and shared publicly. 
            // For this simple single-file demo, we use a static salt so both generate the same key.
            const salt = enc.encode("static-salt-for-demo-purpose"); 

            return window.crypto.subtle.deriveKey(
                {
                    name: "PBKDF2",
                    salt: salt,
                    iterations: 100000,
                    hash: "SHA-256"
                },
                keyMaterial,
                { name: "AES-GCM", length: 256 },
                false,
                ["encrypt", "decrypt"]
            );
        }

        // 2. Encrypt
        async function encryptMessage(text) {
            const key = await getCryptoKey();
            const iv = window.crypto.getRandomValues(new Uint8Array(12)); // Random IV
            const encodedText = new TextEncoder().encode(text);

            const cipherBuffer = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv },
                key,
                encodedText
            );

            // Convert buffers to Arrays for PeerJS transport
            return {
                iv: Array.from(iv),
                cipher: Array.from(new Uint8Array(cipherBuffer))
            };
        }

        // 3. Decrypt
        async function decryptMessage(package) {
            const key = await getCryptoKey();
            const iv = new Uint8Array(package.iv);
            const cipher = new Uint8Array(package.cipher);

            const decryptedBuffer = await window.crypto.subtle.decrypt(
                { name: "AES-GCM", iv: iv },
                key,
                cipher
            );

            return new TextDecoder().decode(decryptedBuffer);
        }

        // --- UI Logic ---
        
        async function sendMessage() {
            const text = msgInput.value;
            if (!text) return;

            const password = document.getElementById('secret-key').value;
            if(!password) {
                alert("您必须先设置一个秘密密码！");
                return;
            }

            try {
                const encryptedPackage = await encryptMessage(text);
                
                if (conn && conn.open) {
                    conn.send(encryptedPackage);
                    addMessageToUI(text, 'sent');
                    msgInput.value = '';
                } else {
                    alert("未连接到对等方。");
                }
            } catch (e) {
                console.error(e);
                alert("加密失败。请检查控制台。");
            }
        }

        function addMessageToUI(text, type) {
            const div = document.createElement('div');
            div.className = `flex w-full ${type === 'sent' ? 'justify-end' : 'justify-start'}`;
            
            let bgClass = type === 'sent' ? 'bg-blue-500 text-white' : 'bg-white border border-gray-300 text-gray-800';
            if(type === 'error') bgClass = 'bg-red-100 text-red-600 border border-red-200';

            div.innerHTML = `
                <div class="message-bubble px-4 py-2 rounded-lg shadow-sm ${bgClass} text-sm">
                    ${escapeHtml(text)}
                </div>
            `;
            chatBox.appendChild(div);
            chatBox.scrollTop = chatBox.scrollHeight;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function copyId() {
            const id = document.getElementById('my-id');
            id.select();
            document.execCommand('copy');
        }
        
        function handleSaveIdToggle() {
            const checkbox = document.getElementById('save-id-checkbox');
            const isChecked = checkbox.checked;
            
            // Save the preference
            localStorage.setItem('save_id_preference', isChecked.toString());
            
            if (isChecked) {
                // Save current ID
                const currentId = document.getElementById('my-id').value;
                if (currentId) {
                    localStorage.setItem('my_chat_app_id', currentId);
                    alert("该 ID 将被记住。请重新加载页面以在下次访问时使用保存的 ID。");
                }
            } else {
                // Clear saved ID
                localStorage.removeItem('my_chat_app_id');
                alert("该 ID 将不会被保存。您将在页面重新加载时获得一个新的随机 ID。");
            }
        }
        
        // Allow Enter key to send
        msgInput.addEventListener("keypress", function(event) {
            if (event.key === "Enter") {
                sendMessage();
            }
        });
    </script>
</body>
</html>